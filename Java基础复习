1.面向对象程序设计的特征
  面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象是将功能封装进对象，强调具有功能的对象。
  思想的好处：
    是符合人们思考习惯的一种思想；
    将复杂的事情简单化了；
    将程序员从执行者变成了指挥者； 注：比如我要达到某种结果我要是用某个功能，我就寻找能帮我达到该结果的功能的对象，如果该对象具备了该功能 那么我拿到该对象，也就可以使用该对象的功能。如我要洗衣服我就买洗衣机，至于怎么洗我不管。
  面向对象语言有三大特点：封装，多态，继承。
  封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。
  继承: 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
  多态: 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定， 即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
  谁拥有数据，谁就对外提供操作这些数据的方法。
 
2.多态实现的机制是什么
	靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法， 也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
	
3.abstract class 和interface有什么区别？
含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。 abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法， 那么子类也必须定义为abstract类型。接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。 接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 下面比较一下两者的语法区别：
 抽象类可以有构造方法，接口中不能有构造方法。
 抽象类中可以有普通成员变量，接口中没有普通成员变量
 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行）,但接口中的抽象方法只能是public类型的， 并且默认即为public abstract类型。
 抽象类中可以包含静态方法，接口中不能包含静态方法
 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
 一个类可以实现多个接口，但只能继承一个抽象类。
abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?
abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。 例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码， 可以发现FileOutputStream的open方法的定义如下：
private native void open(String name) throws FileNotFoundException; 如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。 由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法， java中对应的方法不需要写具体的代码，但需要在前面声明native。关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中， 从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this， 而抽象方法上无法确定this是什么。

4.什么是内部类？
内部类是在一个类内部定义的类，内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中。
在方法体外面定义的内部类的访问类型可以使public，protect，默认的，private等四种，他们决定这个内部类是否对其他类可见。在外部创建内部类时，一定要先创建外部类的实例对象，然后用外部类的实例对象来创建内部类的实例对象。
在方法内部定义的外部类前面不能有访问类型修饰符，就像方法中的局部变量一样，但这种内部类前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的，其他类无法引用这种内部类，但这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须先顶一下，后使用，及内部类的定义代码必须出现在该类之前，与方法中局部变量先定义在使用的道理相同。这种内部类可以访问方法体重的局部变量，但是，该局部变量钱不许家final修饰符。

5.内部类可以引用它包含类的成员吗？有没有限制？
可以，如果不是静态内部类就没有限制，如果把静态嵌套类当做内部类的一种特例，这种情况下不能访问外部类的普通成员变量，只能访问外部类中的静态成员。

6.匿名内部类是否可以继承其他类，是否可以用implements实现inferface？
可以继承其他类或实现其他接口。

7.jdk中哪些类不能继承？
不能继承的类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System，String，StringBuffer等都是基本类型。
